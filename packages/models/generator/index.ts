import { Breeds, WEIGHT, IMAGE, NFT } from "@app/backend/models";
import { ClassType } from "@app/types";
import { buildSchema, getClass } from "@typegoose/typegoose";
import Bluebird from "bluebird";
import fs from "fs";
import { compile, JSONSchema } from "json-schema-to-typescript";
import { SchemaType, SchemaTypes } from "mongoose";
import path from "path";

const typeFile = path.resolve(__dirname, "../types.d.ts");
const inputFile = path.resolve(__dirname, "../input.d.ts");

const models: ClassType<any>[] = [Breeds, WEIGHT, IMAGE, NFT];

async function extractFieldType(
  field: SchemaType,
  inputType: boolean = false
): Promise<any> {
  switch (field.constructor) {
    case SchemaTypes.Number:
    case SchemaTypes.Boolean:
    case SchemaTypes.Date: {
      const type = (field as any).instance?.toLowerCase();
      return { type };
    }
    case SchemaTypes.String: {
      const schema: Record<string, any> = { type: "string" };
      if ((field as any).enumValues?.length) {
        schema.enum = (field as any).enumValues;
      }
      return schema;
    }
    case SchemaTypes.ObjectId:
      if ((field as any).options?.ref) {
        return { tsType: (field as any).options.ref };
      }

      return { type: "string" };
    case SchemaTypes.DocumentArray:
    case SchemaTypes.Array: {
      return {
        type: "array",
        items: await extractFieldType((field as any).caster, inputType)
      };
    }

    default:
      // catch Embeded & EmbededDocument
      const cls: any = getClass((field as any).schema.methods);
      await extractType(cls, inputType);
      return { tsType: inputType ? `${cls.name}Input` : cls.name };
  }
}

async function extractType(model: ClassType<any>, inputType: boolean = false) {
  const properties: Record<string, any> = {};
  const required: string[] = [];
  const output: JSONSchema = {
    type: "object",
    properties,
    required,
    additionalItems: false,
    additionalProperties: false
  };

  const schema = buildSchema(model);
  await Bluebird.mapSeries(Object.keys(schema.paths), async (path) => {
    if (inputType && path === "_id") return;

    const fieldSchema = schema.paths[path];

    if ((fieldSchema as any).options.hide) return;
    if (inputType && (fieldSchema as any).options.readonly) return;

    const jsonSchema = await extractFieldType(fieldSchema, inputType);
    properties[path] = jsonSchema;
    if ((fieldSchema as any).isRequired) {
      required.push(path);
    }
  });

  const typeDef = await compile(
    output,
    inputType ? `${model.name}Input` : model.name,
    { bannerComment: null }
  );
  fs.writeFileSync(inputType ? inputFile : typeFile, typeDef, { flag: "a" });
}

function printHeader(file: string) {
  fs.writeFileSync(
    file,
    [
      "/**",
      " * This file was automatically generated by json-schema-to-typescript.",
      " * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,",
      " * and run `yarn generate` to regenerate this file.",
      " */",
      ""
    ].join("\n")
  );
}

async function generate() {
  printHeader(typeFile);
  printHeader(inputFile);

  await Bluebird.mapSeries(models, async (model) => {
    await extractType(model);
    await extractType(model, true);
  });
}

generate();
